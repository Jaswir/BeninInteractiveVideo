Computers suck at math. If you don't believe me, look at this code. We have number 1 which is 0.1 and we have number 2 which is 0.2. If number 1 plus number 2 is equal to 0.3, computers are good at math. Otherwise, computers suck at math. Let's run this. As you can see, computers can't even do this basic calculation that any 4th grader would be able to do in a couple of seconds. But wait, maybe it's just a bug in Python. Let's write the same code in JavaScript, Java, and C++. Well, that was a big fail. What's even more weird is that if you change the number 2 to 0.1 and check for number 1 plus number 2 equal to 0.2, it starts giving the correct answer. So is it fair to say that computers suck at math? Well, not exactly. To understand why this is happening, we need to know how computers store numbers. I'm sure you already know that computers store numbers in their binary representations or 0s and 1s. In binary representation, 1 is 1, 2 is 10, and 3 is 11. To convert any number into its binary representation, simply keep dividing the number by 2 until the quotient becomes 0 and the sequence of remainders would be its binary representation. Let's say you want binary representation of 42. Divide it by 2 and keep track of the remainder. Now divide 21 by 2 and write down the remainder. Keep doing this until the quotient is 0. The sequence of remainders which is 101010 is the binary representation of 42. Now that you know what the binary representation of 42 is, let's see how a computer would store it in memory. A computer stores the information in the form of bits, which is short for binary digits. A bit can either be 0 or 1. So to store 42 or 101010 in memory, we need 6 bits. Well, not exactly. You see, in most languages when you declare an integer variable, computer would go ahead and allocate a fixed memory to it. For example, in Java, an integer is 32 bits. So the rightmost 6 bits would be used to store the binary representation of 42 and these other bits in the front would be set to 0. Given that you have this information now, here is a question for you. What is the maximum value of an integer that you can store in Java? You can pause the video and leave your answer in the comments. Since we are talking about an integer which can be positive or negative, we need one bit to store the information about the sign of an integer. So we have 31 bits left to store the value. To make the highest number using 31 bits, you can set them all to 1 and the number you get by doing that is what you see on the screen. The fact that computers cannot store values beyond a certain point is the reason they are not able to do basic calculations on fractions like 0.1 and 0.2. Let me explain this by showing you how computers store fractions. Let's take the example of 0.75. If you remember from earlier, we keep dividing an integer by 2 until we get 0 to get its binary representation. For fractions, we do the opposite. Instead of dividing, we multiply by 2 until we get 0. Let me show you. We start by multiplying 0.75 by 2. We keep track of the number before the decimal. We take the fractional part which is 0.5 and multiply that by 2 now. Store the number before the decimal and we stop because we have hit 0. We take these ones that we were storing on the side and add a 0 and a decimal before them and voila! We have got the binary representation of 0.75 which is 0.11. Now computers cannot store decimals directly and there is a way to convert 0.11 to just 0s and 1s but for the purpose of this video, I am going to skip that. If you are curious, you can read about IEEE 754 floating point format. Moving on, let's see how to store 0.1 in binary. Multiply 0.1 by 2 and we get 0 before decimal and 0.2 after decimal. Multiply 0.2 by 2 and we get 0 before decimal and 0.4 after decimal. Do that 3 more times and you will see that you have 0.2 again. What does that mean? If you continue this process, you will see that these 4 steps keep repeating again and again. In other words, 0.1 in binary representation is a never ending sequence. Writing 0.1 in binary is similar to writing 1 by 3 in decimal. It just never ends. And as we saw earlier, computers have to put a limit to how many bits they can use for a number. In the case of fractions, computers only store them until 23 digits after decimal. That's for single precision. There is a whole discussion about single vs double precision which I am skipping here. Anyway, just like you cannot read and understand 1 by 3 precisely in decimal representation, computers cannot read and understand 0.1 precisely in binary representation. When you try to find binary for 0.2, you will find that the same 4 steps repeat again and again which means that computers cannot read and understand 0.2 precisely either. So, going back to the original question, why does adding 0.1 in 0.2 not result in 0.3? Well, here is a simple exercise to understand that. Divide 1 by 3 and 2 by 3. Use only 4 digits after decimal. Add them up to see if they are equal to 1. If you think that you have understood this completely, think again. Explain to me why changing 0.2 to 0.1 in the original code works. My name is Sahil and I will be waiting for your answer.